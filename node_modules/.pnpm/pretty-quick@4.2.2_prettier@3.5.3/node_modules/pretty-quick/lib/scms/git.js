"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stageFile = exports.getUnstagedChangedFiles = exports.getChangedFiles = exports.getSinceRevision = exports.detect = exports.name = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const core_1 = require("@pkgr/core");
const tinyexec_1 = require("tinyexec");
exports.name = 'git';
const detect = (directory) => {
    const found = (0, core_1.findUp)(path_1.default.resolve(directory), '.git', true);
    return found ? path_1.default.dirname(found) : null;
};
exports.detect = detect;
const runGit = (directory, args) => (0, tinyexec_1.exec)('git', args, {
    nodeOptions: {
        cwd: directory,
    },
});
const getLines = (tinyexecOutput) => tinyexecOutput.stdout.split('\n');
const getSinceRevision = async (directory, { staged, branch }) => {
    try {
        let revision = 'HEAD';
        if (!staged) {
            const revisionOutput = await runGit(directory, [
                'merge-base',
                'HEAD',
                branch || 'master',
            ]);
            revision = revisionOutput.stdout.trim();
        }
        const revParseOutput = await runGit(directory, [
            'rev-parse',
            '--short',
            revision,
        ]);
        return revParseOutput.stdout.trim();
    }
    catch (err) {
        const error = err;
        if (/HEAD/.test(error.message) ||
            (staged && /Needed a single revision/.test(error.message))) {
            return null;
        }
        throw error;
    }
};
exports.getSinceRevision = getSinceRevision;
const getChangedFiles = async (directory, revision, staged) => [
    ...getLines(await runGit(directory, [
        'diff',
        '--name-only',
        staged ? '--cached' : null,
        '--diff-filter=ACMRTUB',
        revision,
    ].filter(Boolean))),
    ...(staged
        ? []
        : getLines(await runGit(directory, [
            'ls-files',
            '--others',
            '--exclude-standard',
        ]))),
].filter(Boolean);
exports.getChangedFiles = getChangedFiles;
const getUnstagedChangedFiles = (directory) => {
    return (0, exports.getChangedFiles)(directory, null, false);
};
exports.getUnstagedChangedFiles = getUnstagedChangedFiles;
const stageFile = (directory, file) => runGit(directory, ['add', file]);
exports.stageFile = stageFile;
//# sourceMappingURL=git.js.map